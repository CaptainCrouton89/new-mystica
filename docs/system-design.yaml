# System Design
# Architecture, components, data flow, and technical decisions.

status: draft
last_updated: 2025-10-19

overview:
  goal: "Build a location-based mobile RPG with real-time GPS tracking, combat mechanics, and crafting progression. System must handle location queries, combat sessions, AI item generation, and persistent user data. Designed for thousands of concurrent mobile clients with low latency (<500ms API response)."
  architecture_diagram: |
    ```mermaid
    graph TB
        subgraph "iOS/macOS Client"
            A[SwiftUI App] --> B[CoreLocation GPS]
            A --> C[SwiftData Cache]
            A --> D[Google Maps SDK]
        end

        subgraph "Backend API (Express.js)"
            E[API Gateway] --> F[Auth Middleware]
            F --> G[Location Service]
            F --> H[Combat Service]
            F --> I[Inventory Service]
            F --> J[Crafting Service]
            F --> K[AI Generation Service]
        end

        subgraph "Data Layer"
            L[Supabase PostgreSQL]
            M[Supabase Auth]
            N[Redis Cache]
        end

        subgraph "External Services"
            O[Google Maps API]
            P[AI Provider (OpenAI/Anthropic)]
        end

        A -->|HTTPS/JSON| E
        B -->|Coordinates| A
        D -->|Map Tiles| O
        G --> L
        H --> L
        H --> N
        I --> L
        J --> L
        K --> P
        K --> L
        F --> M
    ```

core_components:
  - component: "iOS/macOS Client (SwiftUI)"
    description: "Native mobile app for iOS 17+ and macOS 14+. Handles UI rendering, GPS tracking, map display, combat animations, and local data caching with SwiftData. Communicates with backend via REST APIs."
    dependencies:
      - "Google Maps SDK for iOS"
      - "CoreLocation framework"
      - "SwiftData for offline caching"
      - "Supabase Swift SDK for auth"

  - component: "API Gateway (Express.js)"
    description: "RESTful API backend serving all client requests. Routes to service modules, enforces authentication via JWT middleware, handles error responses. Deployed on Railway with auto-scaling."
    dependencies:
      - "Express.js 4.16.x"
      - "Supabase Auth for JWT validation"
      - "CORS middleware for client requests"

  - component: "Location Service"
    description: "Manages spawn locations and enemy assignments. Handles /locations/nearby queries with geospatial distance calculations. Returns locations within radius sorted by distance."
    dependencies:
      - "PostgreSQL PostGIS extension for geo queries"
      - "Locations table in Supabase"

  - component: "Combat Service"
    description: "Manages combat sessions in-memory (Redis) with TTL expiration. Calculates damage based on player stats, enemy stats, and timing multiplier. Awards items/pets on victory."
    dependencies:
      - "Redis for session storage (TTL: 15 min)"
      - "Items and enemies tables"
      - "Stat calculation logic"

  - component: "Inventory Service"
    description: "Manages player-owned items and pets. Handles equipping/unequipping, stat aggregation, and inventory queries. Validates item ownership before mutations."
    dependencies:
      - "Items table (owner_id FK)"
      - "Users table for ownership validation"

  - component: "Crafting Service"
    description: "Handles item fusion with async timers. Validates crafting rules (same type, same generation, max Gen3). Consumes parent items immediately, generates child item on timer completion."
    dependencies:
      - "Crafting_sessions table"
      - "AI Generation Service for child items"
      - "Background job queue (pg_cron or Redis Queue)"

  - component: "AI Generation Service"
    description: "Generates unique item descriptions and stat distributions via AI (OpenAI/Anthropic). Validates stat distributions sum to 1.0. Caches generated items to avoid regeneration."
    dependencies:
      - "OpenAI or Anthropic API"
      - "Item_templates table for caching"

  - component: "Supabase PostgreSQL"
    description: "Primary database for all persistent data: users, items, locations, enemies, crafting sessions. Provides geospatial queries via PostGIS, ACID transactions, and row-level security."
    dependencies:
      - "Supabase hosted PostgreSQL"
      - "PostGIS extension for location queries"

  - component: "Supabase Auth"
    description: "Manages user authentication, password hashing, email verification, and JWT token issuance. Integrates with backend via JWT validation middleware."
    dependencies:
      - "Supabase Auth service"
      - "Email provider for verification emails"

  - component: "Redis Cache"
    description: "In-memory cache for combat sessions, active location markers, and frequently accessed data. Reduces database load and improves API response time."
    dependencies:
      - "Redis Cloud or Railway Redis addon"

data_flow: |
  **User Registration Flow:**
  1. Client → Supabase Auth: signUp({email, password})
  2. Supabase Auth → Client: {access_token, refresh_token}
  3. Client → Backend API: POST /profile/init (with token)
  4. Backend → PostgreSQL: INSERT user record
  5. Client → Map Screen

  **Location Discovery Flow:**
  1. Client CoreLocation → GPS coordinates (lat, lng)
  2. Client → Backend API: GET /locations/nearby?lat={lat}&lng={lng}&radius=5000
  3. Backend → PostgreSQL: SELECT locations WHERE distance(lat, lng) < 5000
  4. Backend → Client: {locations: [{id, lat, lng, enemy_type, distance}]}
  5. Client → Google Maps: Display markers

  **Combat Flow:**
  1. Client → Backend API: POST /combat/start {location_id}
  2. Backend → PostgreSQL: SELECT enemy WHERE location_id = {id}
  3. Backend → PostgreSQL: SELECT equipped items WHERE owner_id = {player_id}
  4. Backend → Redis: Store combat session {player_hp, enemy_hp, stats}
  5. Backend → Client: {session_id, enemy, player_stats}
  6. Client → Backend API: POST /combat/attack {session_id, tap_accuracy}
  7. Backend → Redis: GET session, calculate damage, update HPs
  8. Backend → Client: {damage_dealt, enemy_damage, player_hp, enemy_hp, status}
  9. Repeat until victory/defeat
  10. Client → Backend API: POST /combat/complete {session_id, result}
  11. Backend → PostgreSQL: INSERT item (if victory)
  12. Backend → Client: {reward: {item}}

  **Crafting Flow:**
  1. Client → Backend API: POST /crafting/start {parent_item_1, parent_item_2}
  2. Backend → PostgreSQL: Validate items, DELETE parents
  3. Backend → PostgreSQL: INSERT crafting_session {duration, completion_time}
  4. Backend → Client: {session_id, completion_time}
  5. Background Job → (wait for timer)
  6. Background Job → AI Service: Generate child item
  7. Background Job → PostgreSQL: INSERT child item, UPDATE session status
  8. Push Notification → Client: "Crafting complete!"
  9. Client → Backend API: POST /crafting/complete {session_id}
  10. Backend → Client: {child_item}

tech_stack:
  frontend: "SwiftUI (native iOS/macOS), SwiftData (local persistence), CoreLocation (GPS), Google Maps SDK (map rendering)"
  backend: "Express.js 4.16.x (Node.js), Supabase SDK (auth + database), Redis (session cache), OpenAI/Anthropic SDK (AI generation)"
  database: "Supabase PostgreSQL with PostGIS (geospatial queries), Redis (in-memory cache for sessions)"
  infrastructure: "Railway (backend hosting with auto-deploy), Supabase Cloud (database + auth), Redis Cloud (cache), Google Cloud (Maps API), OpenAI/Anthropic (AI API)"

scalability_reliability:
  load_expectations: |
    - Light MVP (3 days): 10 concurrent users, local testing only
    - Full MVP (2 weeks): 100 concurrent users, beta testers
    - Finished Product (2 months): 1,000+ concurrent users, public launch
    - API response time target: <500ms for location/inventory queries, <200ms for combat actions
    - Database: ~10k locations globally, ~100k items/pets, ~1k active combat sessions at peak

  redundancy: |
    - Database: Supabase provides automated backups (daily snapshots, point-in-time recovery)
    - Backend: Railway auto-restarts on failure (max 10 retries per policy)
    - Redis: Ephemeral data (combat sessions) can be reconstructed, acceptable to lose on crash
    - Client: SwiftData caches critical data (inventory, equipped items) for offline resilience

  observability: |
    - Logging: Express.js Morgan middleware for request logging, sent to Railway logs
    - Monitoring: Railway dashboard for uptime, response time, error rate
    - Alerts: Configure Railway alerts for 5xx errors, response time > 2s, crash events
    - Analytics: Track key metrics (combat win rate, crafting frequency, location visits) via custom events to backend
    - Error Tracking: Sentry integration for client and backend error reporting (post-MVP)

security:
  authentication: "Supabase Auth with JWT tokens (1hr expiry), refresh tokens (30 days), secure Keychain storage on client"
  authorization: "Row-level security (RLS) in Supabase ensures players can only access their own items/inventory"
  api_security: "HTTPS only (enforced by Railway), CORS restricted to mobile app origins, rate limiting (100 req/min per IP)"
  data_privacy: "Email/password hashed by Supabase (bcrypt), no PII stored beyond email, GDPR-compliant account deletion endpoint"

performance_optimizations:
  client: |
    - SwiftData caches inventory, equipment locally (reduces API calls)
    - Map markers clustered when zoomed out (reduces rendering load)
    - Lazy loading for inventory lists (paginate 50 items at a time)
    - Combat animations at 60fps (hardware-accelerated SwiftUI)

  backend: |
    - Redis caches active combat sessions (avoid DB queries per attack)
    - Location queries use PostGIS spatial index (O(log n) lookups)
    - AI-generated items cached in item_templates (avoid redundant API calls)
    - Database connection pooling (max 20 connections via Supabase)

  database: |
    - Indexes on: owner_id, location_id, is_equipped, session_id
    - Geospatial index on locations (lat, lng) via PostGIS
    - Partitioning items table by generation if >1M rows (future)

future_considerations:
  - Real-time multiplayer: WebSocket server for live co-op battles (Phase 2)
  - Trading system: Item marketplace with escrow transactions (Phase 2)
  - Leaderboards: Global/regional rankings by total stats or rare items collected
  - Push notifications: Daily quests, event notifications, crafting completion
  - Offline mode: Allow combat with cached enemies, sync on reconnect
  - Analytics dashboard: Admin panel to monitor game balance, player retention, economy health
