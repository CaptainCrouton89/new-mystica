# System Design
# Architecture, components, data flow, and technical decisions.

status: draft
last_updated: 2025-01-27

overview:
  goal: "Build a location-based mobile RPG with real-time GPS tracking, combat mechanics, and crafting progression. System must handle location queries, combat sessions, AI item generation, and persistent user data. Designed for thousands of concurrent mobile clients with low latency (<500ms API response)."
  architecture_diagram: |
    ```mermaid
    graph TB
        subgraph "iOS/macOS Client"
            A[SwiftUI App] --> B[CoreLocation GPS]
            A --> C[SwiftData Cache]
            A --> D[Google Maps SDK]
        end

        subgraph "Backend API (Express.js)"
            E[API Gateway] --> F[Auth Middleware]
            F --> G[Location Service]
            F --> H[Combat Service]
            F --> I[Inventory Service]
            F --> J[Crafting Service]
            F --> K[AI Generation Service]
        end

        subgraph "Data Layer"
            L[Supabase PostgreSQL]
            M[Supabase Auth]
            N[Redis Cache]
        end

        subgraph "External Services"
            O[Google Maps API]
            P[AI Provider (OpenAI/Anthropic)]
        end

        A -->|HTTPS/JSON| E
        B -->|Coordinates| A
        D -->|Map Tiles| O
        G --> L
        H --> L
        H --> N
        I --> L
        J --> L
        K --> P
        K --> L
        F --> M
    ```

core_components:
  - component: "iOS/macOS Client (SwiftUI)"
    description: "Native mobile app for iOS 17+ and macOS 14+. Handles UI rendering, GPS tracking, map display, combat animations, and local data caching with SwiftData. Communicates with backend via REST APIs."
    dependencies:
      - "Google Maps SDK for iOS"
      - "CoreLocation framework"
      - "SwiftData for offline caching"
      - "Supabase Swift SDK for auth"

  - component: "API Gateway (Express.js)"
    description: "RESTful API backend serving all client requests. Routes to service modules, enforces authentication via JWT middleware, handles error responses. Deployed on Railway with auto-scaling."
    dependencies:
      - "Express.js 4.16.x"
      - "Supabase Auth for JWT validation"
      - "CORS middleware for client requests"

  - component: "Location Service"
    description: "Manages spawn locations and level-aware pool system for enemy/loot assignments. Handles /locations/nearby queries with geospatial distance calculations. Implements tag/filter-based pool system where pools are level-specific and apply based on location attributes (location_type, state, country, coordinates). Returns locations within radius sorted by distance with dynamically assigned enemies from matching pools."
    dependencies:
      - "PostgreSQL PostGIS extension for geo queries"
      - "Locations table with location_type, state_code, country_code metadata"
      - "EnemyPools and LootPools with filter-based matching logic"
      - "Pool member tables for weighted random selection"

  - component: "Combat Service"
    description: "Manages combat sessions in-memory (Redis) with TTL expiration. Calculates damage based on player stats, enemy stats, and timing multiplier. Awards items/pets on victory. Uses level-aware pool system to dynamically select enemies and loot drops based on player level and location attributes."
    dependencies:
      - "Redis for session storage (TTL: 15 min)"
      - "Items and enemies tables"
      - "EnemyPools and LootPools for dynamic assignment"
      - "Stat calculation logic"

  - component: "Inventory Service"
    description: "Manages player-owned items and pets. Handles equipping/unequipping, stat aggregation, and inventory queries. Validates item ownership before mutations."
    dependencies:
      - "Items table (owner_id FK)"
      - "Users table for ownership validation"

  - component: "Crafting Service"
    description: "Handles item fusion with async timers. Validates crafting rules (same type, same generation, max Gen3). Consumes parent items immediately, generates child item on timer completion."
    dependencies:
      - "Crafting_sessions table"
      - "AI Generation Service for child items"
      - "Background job queue (pg_cron or Redis Queue)"

  - component: "AI Generation Service"
    description: "Generates unique item descriptions and stat distributions via AI (OpenAI/Anthropic). Also generates pet personality dialogue (F-11) and enemy trash-talk (F-12) during combat. Validates stat distributions sum to 1.0. Caches generated items to avoid regeneration. For pet chatter (F-11), uses personality prompts and combat context to generate supportive dialogue. For enemy chatter (F-12), uses enemy type traits and player history to generate antagonistic trash-talk."
    dependencies:
      - "OpenAI or Anthropic API (GPT-4.1-nano or GPT-4o-mini recommended)"
      - "Item_templates table for caching"
      - "Pet_personalities seed data for dialogue generation (F-11)"
      - "Enemy_types seed data for trash-talk generation (F-12)"
      - "Player_combat_history for enemy AI context (F-12)"
      - "Combat session context from Redis (F-11, F-12)"

  - component: "Supabase PostgreSQL"
    description: "Primary database for all persistent data including core entities (Users, Items, ItemTypes, Materials, MaterialInstances), pet system (Pets, PetPersonalities), enemy AI (EnemyTypes, PlayerCombatHistory), and analytics (CombatChatterLog, EnemyChatterLog). Full schema documented in data-plan.yaml. Provides geospatial queries via PostGIS, ACID transactions, and row-level security."
    dependencies:
      - "Supabase hosted PostgreSQL"
      - "PostGIS extension for location queries"
      - "Comprehensive schema design in data-plan.yaml"

  - component: "Supabase Auth"
    description: "Manages user authentication, password hashing, email verification, and JWT token issuance. Integrates with backend via JWT validation middleware."
    dependencies:
      - "Supabase Auth service"
      - "Email provider for verification emails"

  - component: "Redis Cache"
    description: "In-memory cache for combat sessions, active location markers, and frequently accessed data. Reduces database load and improves API response time."
    dependencies:
      - "Redis Cloud or Railway Redis addon"

data_flow: |
  **User Registration Flow:**
  1. Client → Supabase Auth: signUp({email, password})
  2. Supabase Auth → Client: {access_token, refresh_token}
  3. Client → Backend API: POST /profile/init (with token)
  4. Backend → PostgreSQL: INSERT user record
  5. Client → Map Screen

  **Location Discovery Flow:**
  1. Client CoreLocation → GPS coordinates (lat, lng)
  2. Client → Backend API: GET /locations/nearby?lat={lat}&lng={lng}&radius=5000
  3. Backend → PostgreSQL: SELECT locations WHERE distance(lat, lng) < 5000
  4. Backend → Client: {locations: [{id, lat, lng, enemy_type, distance}]}
  5. Client → Google Maps: Display markers

  **Combat Flow:**
  1. Client → Backend API: POST /combat/start {location_id}
  2. Backend → PostgreSQL: SELECT location metadata (location_type, state_code, country_code, lat, lng)
  3. Backend → PostgreSQL: Calculate player combat level from avg equipped item level
  4. Backend → PostgreSQL: Query matching EnemyPools based on combat level and location filters
  5. Backend → PostgreSQL: Aggregate EnemyPoolMembers, select enemy via weighted random
  6. Backend → PostgreSQL: Query matching LootPools for later drop calculation
  7. Backend → PostgreSQL: SELECT equipped items WHERE owner_id = {player_id}
  8. Backend → Redis: Store combat session {player_hp, enemy_hp, stats, applied_pools}
  9. Backend → Client: {session_id, enemy, player_stats}
  10. Client → Backend API: POST /combat/attack {session_id, tap_accuracy}
  11. Backend → Redis: GET session, calculate damage, update HPs
  12. Backend → Client: {damage_dealt, enemy_damage, player_hp, enemy_hp, status}
  13. Repeat until victory/defeat
  14. Client → Backend API: POST /combat/complete {session_id, result}
  15. Backend → PostgreSQL: Use stored LootPools to calculate drops (if victory)
  16. Backend → PostgreSQL: INSERT materials/items (if victory)
  17. Backend → Client: {reward: {items, materials}}

  **Crafting Flow:**
  1. Client → Backend API: POST /crafting/start {parent_item_1, parent_item_2}
  2. Backend → PostgreSQL: Validate items, DELETE parents
  3. Backend → PostgreSQL: INSERT crafting_session {duration, completion_time}
  4. Backend → Client: {session_id, completion_time}
  5. Background Job → (wait for timer)
  6. Background Job → AI Service: Generate child item
  7. Background Job → PostgreSQL: INSERT child item, UPDATE session status
  8. Push Notification → Client: "Crafting complete!"
  9. Client → Backend API: POST /crafting/complete {session_id}
  10. Backend → Client: {child_item}

  **Pet Chatter Flow (F-11):**
  1. Player equips pet → Client → Backend API: PUT /pets/{pet_id}/personality {personality_type}
  2. Backend → PostgreSQL: INSERT/UPDATE player_pet_personalities
  3. During combat: Player taps attack dial → Combat system calculates outcome
  4. Client → Backend API: POST /combat/pet-chatter {session_id, event_type, event_details}
  5. Backend → PostgreSQL: JOIN player_pet_personalities → get personality_type
  6. Backend → PostgreSQL: SELECT pet_personalities WHERE personality_type = {type}
  7. Backend → Redis: GET combat session context {player_hp, enemy_hp, turn_count}
  8. Backend → AI Service: Construct prompt with personality + combat context + event
     - System prompt: base_dialogue_style from pet_personalities
     - Context: "Turn {turn}, Player HP: {hp}%, Enemy HP: {hp}%"
     - Event: "Player attacked for {damage} damage (accuracy: {accuracy})"
     - Instruction: "Generate 1-2 sentence reaction. Be {verbosity}."
  9. AI Service → Backend: Generated dialogue (with 1-2s timeout)
  10. Backend → PostgreSQL: INSERT combat_chatter_log (for analytics)
  11. Backend → Client: {dialogue, personality_type, generation_time_ms}
  12. Client: Display dialogue in speech bubble above pet sprite (2-3s duration)
  13. If AI timeout/error → Fallback: select random example_phrase from pet_personalities

  **Enemy Chatter Flow (F-12):**
  1. Combat starts: Client → Backend API: POST /combat/start {location_id}
  2. Backend → PostgreSQL: SELECT enemy type for location
  3. Backend → PostgreSQL: SELECT/INSERT player_combat_history {player_id, location_id} (initialize if first attempt)
  4. During combat: Combat event occurs (player hits, enemy hits, HP threshold, etc.)
  5. Client → Backend API: POST /combat/enemy-chatter {session_id, event_type, event_details}
  6. Backend → Redis: GET combat_session {enemy_type, player_id, location_id, combat_state}
  7. Backend → PostgreSQL: SELECT enemy_types WHERE type = {enemy_type}
  8. Backend → PostgreSQL: SELECT player_combat_history WHERE player_id + location_id
  9. Backend → AI Service: Construct prompt with enemy personality + combat context + player history
     - System prompt: base_dialogue_prompt from enemy_types (tone, traits)
     - Context: "Turn {turn}, Enemy HP: {hp}%, Player HP: {hp}%"
     - Player History: "Player has attempted {attempts} times ({victories}W/{defeats}L), current streak: {streak}"
     - Event: "Player just {action} for {damage} damage (accuracy: {accuracy})"
     - Instruction: "Generate 1-2 sentence trash-talk. Be {verbosity}. Tone: {dialogue_tone}."
  10. AI Service → Backend: Generated dialogue (with 2s timeout)
  11. Backend → PostgreSQL: INSERT enemy_chatter_log (for analytics)
  12. Backend → Client: {dialogue, enemy_type, dialogue_tone, generation_time_ms, player_context_used}
  13. Client: Display dialogue in speech bubble above enemy sprite (2-3s duration)
  14. If AI timeout/error → Fallback: select random example_taunt from enemy_types.example_taunts
  15. On combat end: Backend → PostgreSQL: UPDATE player_combat_history (increment attempts, victories/defeats, update streak)

tech_stack:
  frontend: "SwiftUI (native iOS/macOS), SwiftData (local persistence), CoreLocation (GPS), Google Maps SDK (map rendering)"
  backend: "Express.js 4.16.x (Node.js), Supabase SDK (auth + database), Redis (session cache), OpenAI/Anthropic SDK (AI generation)"
  database: "Supabase PostgreSQL with PostGIS (geospatial queries), Redis (in-memory cache for sessions)"
  infrastructure: "Railway (backend hosting with auto-deploy), Supabase Cloud (database + auth), Redis Cloud (cache), Google Cloud (Maps API), OpenAI/Anthropic (AI API)"

scalability_reliability:
  load_expectations: |
    - Light MVP (3 days): 10 concurrent users, local testing only
    - Full MVP (2 weeks): 100 concurrent users, beta testers
    - Finished Product (2 months): 1,000+ concurrent users, public launch
    - API response time target: <500ms for location/inventory queries, <200ms for combat actions
    - Database: ~10k locations globally, ~100k items/pets, ~1k active combat sessions at peak

  redundancy: |
    - Database: Supabase provides automated backups (daily snapshots, point-in-time recovery)
    - Backend: Railway auto-restarts on failure (max 10 retries per policy)
    - Redis: Ephemeral data (combat sessions) can be reconstructed, acceptable to lose on crash
    - Client: SwiftData caches critical data (inventory, equipped items) for offline resilience

  observability: |
    - Logging: Express.js Morgan middleware for request logging, sent to Railway logs
    - Monitoring: Railway dashboard for uptime, response time, error rate
    - Alerts: Configure Railway alerts for 5xx errors, response time > 2s, crash events
    - Analytics: Track key metrics (combat win rate, crafting frequency, location visits) via custom events to backend
    - Error Tracking: Sentry integration for client and backend error reporting (post-MVP)

security:
  authentication: "Supabase Auth with JWT tokens (1hr expiry), refresh tokens (30 days), secure Keychain storage on client"
  authorization: "Row-level security (RLS) in Supabase ensures players can only access their own items/inventory"
  api_security: "HTTPS only (enforced by Railway), CORS restricted to mobile app origins, rate limiting (100 req/min per IP)"
  data_privacy: "Email/password hashed by Supabase (bcrypt), no PII stored beyond email, GDPR-compliant account deletion endpoint"

performance_optimizations:
  client: |
    - SwiftData caches inventory, equipment locally (reduces API calls)
    - Map markers clustered when zoomed out (reduces rendering load)
    - Lazy loading for inventory lists (paginate 50 items at a time)
    - Combat animations at 60fps (hardware-accelerated SwiftUI)

  backend: |
    - Redis caches active combat sessions (avoid DB queries per attack)
    - Location queries use PostGIS spatial index (O(log n) lookups)
    - AI-generated items cached in item_templates (avoid redundant API calls)
    - Database connection pooling (max 20 connections via Supabase)

  database: |
    - Indexes on: owner_id, location_id, is_equipped, session_id
    - Geospatial index on locations (lat, lng) via PostGIS
    - Partitioning items table by generation if >1M rows (future)

future_considerations:
  - Real-time multiplayer: WebSocket server for live co-op battles (Phase 2)
  - Trading system: Item marketplace with escrow transactions (Phase 2)
  - Leaderboards: Global/regional rankings by total stats or rare items collected
  - Push notifications: Daily quests, event notifications, crafting completion
  - Offline mode: Allow combat with cached enemies, sync on reconnect
  - Analytics dashboard: Admin panel to monitor game balance, player retention, economy health
