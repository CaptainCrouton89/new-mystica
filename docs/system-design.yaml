# System Design
# Architecture, components, data flow, and technical decisions.

status: draft
last_updated: 2025-10-21

overview:
  goal: "Build a location-based mobile RPG with real-time GPS tracking, combat mechanics, and crafting progression. System must handle location queries, combat sessions, AI item generation, and persistent user data. Designed for thousands of concurrent mobile clients with low latency (<500ms API response)."
  architecture_diagram: |
    ```mermaid
    graph TB
        subgraph "iOS/macOS Client"
            A[SwiftUI App] --> B[CoreLocation GPS]
            A --> C[SwiftData Cache]
            A --> D[Google Maps SDK]
        end

        subgraph "Backend API (Express.js)"
            E[API Gateway] --> F[Auth Middleware]
            F --> G[Location Service]
            F --> H[Combat Service]
            F --> I[Inventory Service]
            F --> J[Crafting Service]
            F --> K[AI Generation Service]
        end

        subgraph "Data Layer"
            L[Supabase PostgreSQL]
            M[Supabase Auth]
        end

        subgraph "Style System"
            O[StyleDefinitions]
            P[Style Inheritance Logic]
        end

        subgraph "External Services"
            Q[Google Maps API]
            R[AI Provider (OpenAI/Anthropic)]
        end

        A -->|HTTPS/JSON| E
        B -->|Coordinates| A
        D -->|Map Tiles| Q
        G --> L
        H --> L
        I --> L
        J --> L
        J --> O
        K --> R
        K --> L
        F --> M
    ```

core_components:
  - component: "iOS/macOS Client (SwiftUI)"
    description: "Native mobile app for iOS 17+ and macOS 14+. Handles UI rendering, GPS tracking, map display, combat animations, and local data caching with SwiftData. Communicates with backend via REST APIs."
    dependencies:
      - "Google Maps SDK for iOS"
      - "CoreLocation framework"
      - "SwiftData for offline caching"
      - "Supabase Swift SDK for auth"

  - component: "API Gateway (Express.js)"
    description: "RESTful API backend serving all client requests. Routes to service modules, enforces authentication via JWT middleware, handles error responses. Deployed on Railway with auto-scaling."
    dependencies:
      - "Express.js 4.16.x"
      - "Supabase Auth for JWT validation"
      - "CORS middleware for client requests"

  - component: "Location Service"
    description: "Manages spawn locations and level-aware enemy pool system. Handles /locations/nearby queries with geospatial distance calculations. Implements tag/filter-based EnemyPool system where pools are combat_level-specific and apply based on location attributes (location_type, state, country, coordinates). Returns locations within radius sorted by distance with dynamically assigned enemies from matching pools. Loot determined per-enemy via enemyloot table (no LootPools)."
    dependencies:
      - "PostgreSQL PostGIS extension for geo queries"
      - "Locations table with location_type, state_code, country_code metadata"
      - "EnemyPools with filter-based matching logic (combat_level, location filters)"
      - "EnemyPoolMembers table for weighted random enemy selection"
      - "EnemyLoot table for direct enemy-specific loot queries"

  - component: "Combat Service"
    description: "Manages combat sessions in CombatSessions table with automatic cleanup of expired sessions (15min TTL via scheduled job). Calculates zone-based damage (5-zone system with 0.5x-1.5x multipliers, variable crit chances). Awards materials/items/gold/XP on victory from direct enemyloot table queries. Enemy stats use normalized distribution (sum=1.0) scaled by combat_level × tier.difficulty_multiplier. HP scales with tier ONLY (base_hp × tier.difficulty_multiplier, no combat_level factor). Simulates enemy zone hits using accuracy-based probability distribution. Style inheritance: enemies with style_id drop materials with matching style_id."
    dependencies:
      - "CombatSessions table for persistent session storage"
      - "EnemyTypes table with normalized stats (atk_power_normalized, etc.)"
      - "Tiers table with difficulty/gold/xp multipliers"
      - "EnemyLoot table with polymorphic FK (lootable_type + lootable_id)"
      - "EnemyPools for dynamic enemy assignment (no LootPools)"
      - "StyleDefinitions table for enemy style inheritance"
      - "Zone probability calculation (smooth anchor curves)"
      - "Database cleanup job for expired sessions (WHERE created_at < NOW() - INTERVAL '15 minutes')"

  - component: "Inventory Service"
    description: "Manages player-owned items and pets. Handles equipping/unequipping via UserEquipment table, stat aggregation from ItemMaterials and UserEquipment joins. Validates item ownership before mutations."
    dependencies:
      - "Items table (user_id FK)"
      - "UserEquipment table for equipped state"
      - "ItemMaterials table for material assignments"
      - "Users table for ownership validation"

  - component: "Material Application Service"
    description: "Handles applying up to 3 materials to items (F-04). Manages material stacking (MaterialStacks keyed by user_id, material_id, style_id), creates MaterialInstances when applied, updates ItemMaterials junction table. Computes deterministic combo_hash including style_ids for image lookup. Sets item.is_styled=true if ANY applied material has style_id != 'normal'. If image not cached in ItemImageCache, synchronously generates unique composite image (20s via AI) showing item + materials with style effects, uploads to R2, caches globally for reuse."
    dependencies:
      - "MaterialStacks table (inventory with style_id key)"
      - "MaterialInstances table (applied materials with style_id)"
      - "ItemMaterials table (junction)"
      - "StyleDefinitions table for style inheritance logic"
      - "ItemImageCache table (global cache with style-aware hashing)"
      - "AI Image Generation Service (R2 + Replicate)"
      - "R2 storage for generated images"

  - component: "AI Generation Service"
    description: "Generates unique item descriptions and stat distributions via AI (OpenAI/Anthropic). Also generates pet personality dialogue (F-11) and enemy trash-talk (F-12) during combat. Validates stat distributions sum to 1.0. Caches generated items to avoid regeneration. For pet chatter (F-11), uses personality prompts and combat context to generate supportive dialogue. For enemy chatter (F-12), uses enemy type traits and player history to generate antagonistic trash-talk."
    dependencies:
      - "OpenAI or Anthropic API (gpt-4.1-nano or gpt-4.1-mini recommended)"
      - "Item_templates table for caching"
      - "Pet_personalities seed data for dialogue generation (F-11)"
      - "Enemy_types seed data for trash-talk generation (F-12)"
      - "Player_combat_history for enemy AI context (F-12)"
      - "CombatSessions table for combat context (F-11, F-12)"

  - component: "Style System (StyleDefinitions)"
    description: "Manages visual style variants for items and materials (F-05). StyleDefinitions table defines available styles with spawn_rate, style_name, and visual_modifier. Enemies with style_id drop materials with matching style_id. Items inherit styled status (is_styled=true) when ANY applied material has style_id != 'normal'. MaterialStacks keyed by (user_id, material_id, style_id) to separate inventory by style. Style inheritance ensures visual consistency across combat→materials→items."
    dependencies:
      - "StyleDefinitions table with spawn rates and visual modifiers"
      - "EnemyTypes.style_id for determining material drops"
      - "MaterialStacks with style_id composite key"
      - "MaterialInstances.style_id for applied materials"
      - "Items.is_styled computed from applied materials"
      - "Image generation system for style-aware combo_hash"

  - component: "Supabase PostgreSQL"
    description: "Primary database for all persistent data including core entities (Users, Items, ItemTypes, Materials, MaterialInstances), normalized equipment (UserEquipment, Loadouts, LoadoutSlots), materials system (ItemMaterials), style system (StyleDefinitions, MaterialStacks with style_id), pet system (Pets, PetPersonalities), enemy AI (EnemyTypes with style_id, PlayerCombatHistory), combat sessions (CombatSessions with 15min soft TTL), and analytics (CombatChatterLog, EnemyChatterLog, CombatLogEvents). Full schema documented in data-plan.yaml including style inheritance architecture. Provides geospatial queries via PostGIS, ACID transactions, and row-level security."
    dependencies:
      - "Supabase hosted PostgreSQL"
      - "PostGIS extension for location queries"
      - "StyleDefinitions table for visual style system"
      - "CombatSessions table for active combat state"
      - "Comprehensive schema design in data-plan.yaml"

  - component: "Supabase Auth"
    description: "Manages user authentication, password hashing, email verification, and JWT token issuance. Integrates with backend via JWT validation middleware."
    dependencies:
      - "Supabase Auth service"
      - "Email provider for verification emails"


data_flow: |
  **User Registration Flow:**
  1. Client → Supabase Auth: signUp({email, password})
  2. Supabase Auth → Client: {access_token, refresh_token}
  3. Client → Backend API: POST /profile/init (with token)
  4. Backend → PostgreSQL: INSERT user record
  5. Client → Map Screen

  **Location Discovery Flow:**
  1. Client CoreLocation → GPS coordinates (lat, lng)
  2. Client → Backend API: GET /locations/nearby?lat={lat}&lng={lng}&radius=5000
  3. Backend → PostgreSQL: SELECT locations WHERE distance(lat, lng) < 5000
  4. Backend → Client: {locations: [{id, lat, lng, enemy_type, distance}]}
  5. Client → Google Maps: Display markers

  **Combat Flow (Zone-Based System):**
  1. Client → Backend API: POST /combat/start {location_id}
  2. Backend → PostgreSQL: SELECT location metadata (location_type, state_code, country_code, lat, lng)
  3. Backend → PostgreSQL: Calculate player combat_level from avg equipped item level
  4. Backend → PostgreSQL: Query matching EnemyPools based on combat_level and location filters
  5. Backend → PostgreSQL: Aggregate EnemyPoolMembers, select enemy via weighted random
  6. Backend → PostgreSQL: SELECT EnemyType with normalized stats + Tier with multipliers
  7. Backend: Calculate realized enemy stats (base_atk = normalized × combat_level × tier.difficulty_multiplier, base_def similar, hp = base_hp × tier.difficulty_multiplier)
  8. Backend → PostgreSQL: INSERT CombatSessions {player_hp, enemy_hp, realized_stats, enemy_type_id, combat_log}
  9. Backend → Client: {session_id, enemy_realized_stats, player_stats}
  10. Client → Backend API: POST /combat/attack {session_id, player_zone_hit (1-5)}
  11. Backend: Simulate enemy zone hit using calculateZoneProbabilities(enemy.atk_accuracy_normalized)
  12. Backend: Roll crit based on zone crit chance, apply zone_multiplier × crit_multiplier to base stats
  13. Backend → PostgreSQL: UPDATE CombatSessions {player_hp, enemy_hp, combat_log with zone info}
  14. Backend → Client: {damage_dealt, enemy_damage, player_zone, enemy_zone, crit_info, player_hp, enemy_hp, status}
  15. Repeat attack/defense until victory/defeat
  16. Client → Backend API: POST /combat/complete {session_id, result}
  17. (If victory) Backend → PostgreSQL: SELECT EnemyLoot WHERE enemy_type_id = {id} AND lootable_type = 'material'
  18. (If victory) Backend: Weighted random material selection, apply style_id = enemy.style_id if styled
  19. (If victory) Backend → PostgreSQL: SELECT EnemyLoot WHERE lootable_type = 'item_type' (optional drop)
  20. (If victory) Backend: Calculate gold = 10 × combat_level × tier.gold_multiplier, xp = 20 × combat_level × tier.xp_multiplier
  21. (If victory) Backend → PostgreSQL: INSERT MaterialStacks {user_id, material_id, style_id, quantity: 1}
  22. (If victory) Backend → PostgreSQL: INSERT Items (if item dropped)
  23. Backend → PostgreSQL: UPDATE CombatSessions SET outcome = {result}, rewards = {materials_with_styles, items, gold, xp}
  24. Backend → Client: {reward: {materials: [{material_id, style_id, quantity}], items, gold, xp}}

  **Material Application Flow (F-04, with Image Generation):**
  1. Client → Backend API: POST /items/{item_id}/materials/apply {material_instance_id, slot_index}
  2. Backend → PostgreSQL: BEGIN TRANSACTION
  3. Backend → PostgreSQL: Validate material ownership, slot availability (max 3)
  4. Backend → PostgreSQL: INSERT ItemMaterials {item_id, material_instance_id, slot_index}
  5. Backend → PostgreSQL: Compute material_combo_hash (sorted material_ids + style_ids)
  6. Backend → PostgreSQL: SELECT ItemImageCache WHERE item_type_id={type} AND combo_hash={hash}
  7a. If cached: Backend → PostgreSQL: UPDATE ItemImageCache.craft_count++, UPDATE Items.generated_image_url
  7b. If not cached: Backend → AI Image Service: Generate image (item + materials, 20s sync)
  8. (If 7b) Backend → R2: Upload generated image to R2 bucket
  9. (If 7b) Backend → PostgreSQL: INSERT ItemImageCache {item_type_id, combo_hash, image_url, craft_count=1}
  10a. Backend → PostgreSQL: Check if ANY applied material has style_id != 'normal'
  10b. Backend → PostgreSQL: UPDATE Items {material_combo_hash, generated_image_url, is_styled, image_generation_status='complete'}
  11. Backend → PostgreSQL: COMMIT
  12. Backend → Client: {item, stats, image_url, is_first_craft: boolean, total_crafts: int}

  **Pet Chatter Flow (F-11):**
  1. Player equips pet → Client → Backend API: PUT /pets/{pet_id}/personality {personality_type}
  2. Backend → PostgreSQL: INSERT/UPDATE player_pet_personalities
  3. During combat: Player taps attack dial → Combat system calculates outcome
  4. Client → Backend API: POST /combat/pet-chatter {session_id, event_type, event_details}
  5. Backend → PostgreSQL: JOIN player_pet_personalities → get personality_type
  6. Backend → PostgreSQL: SELECT pet_personalities WHERE personality_type = {type}
  7. Backend → Redis: GET combat session context {player_hp, enemy_hp, turn_count}
  8. Backend → AI Service: Construct prompt with personality + combat context + event
     - System prompt: base_dialogue_style from pet_personalities
     - Context: "Turn {turn}, Player HP: {hp}%, Enemy HP: {hp}%"
     - Event: "Player attacked for {damage} damage (accuracy: {accuracy})"
     - Instruction: "Generate 1-2 sentence reaction. Be {verbosity}."
  9. AI Service → Backend: Generated dialogue (with 1-2s timeout)
  10. Backend → PostgreSQL: INSERT combat_chatter_log (for analytics)
  11. Backend → Client: {dialogue, personality_type, generation_time_ms}
  12. Client: Display dialogue in speech bubble above pet sprite (2-3s duration)
  13. If AI timeout/error → Fallback: select random example_phrase from pet_personalities

  **Enemy Chatter Flow (F-12):**
  1. Combat starts: Client → Backend API: POST /combat/start {location_id}
  2. Backend → PostgreSQL: SELECT enemy type for location
  3. Backend → PostgreSQL: SELECT/INSERT player_combat_history {player_id, location_id} (initialize if first attempt)
  4. During combat: Combat event occurs (player hits, enemy hits, HP threshold, etc.)
  5. Client → Backend API: POST /combat/enemy-chatter {session_id, event_type, event_details}
  6. Backend → PostgreSQL: SELECT CombatSessions WHERE id = {session_id} → {enemy_type, player_id, location_id, player_hp, enemy_hp}
  7. Backend → PostgreSQL: SELECT enemy_types WHERE type = {enemy_type}
  8. Backend → PostgreSQL: SELECT player_combat_history WHERE player_id + location_id
  9. Backend → AI Service: Construct prompt with enemy personality + combat context + player history
     - System prompt: base_dialogue_prompt from enemy_types (tone, traits)
     - Context: "Turn {turn}, Enemy HP: {hp}%, Player HP: {hp}%"
     - Player History: "Player has attempted {attempts} times ({victories}W/{defeats}L), current streak: {streak}"
     - Event: "Player just {action} for {damage} damage (accuracy: {accuracy})"
     - Instruction: "Generate 1-2 sentence trash-talk. Be {verbosity}. Tone: {dialogue_tone}."
  10. AI Service → Backend: Generated dialogue (with 2s timeout)
  11. Backend → PostgreSQL: INSERT enemy_chatter_log (for analytics)
  12. Backend → Client: {dialogue, enemy_type, dialogue_tone, generation_time_ms, player_context_used}
  13. Client: Display dialogue in speech bubble above enemy sprite (2-3s duration)
  14. If AI timeout/error → Fallback: select random example_taunt from enemy_types.example_taunts
  15. On combat end: Backend → PostgreSQL: UPDATE player_combat_history (increment attempts, victories/defeats, update streak)

  **Style Inheritance Flow (F-05):**
  1. Enemy spawns with style_id from EnemyTypes table
  2. Combat victory → Backend determines material drops with enemy's style_id
  3. Backend → PostgreSQL: INSERT MaterialStacks {user_id, material_id, style_id, quantity}
  4. Player applies styled material → Material Application Service checks style_id
  5. Backend → PostgreSQL: INSERT MaterialInstances {material_id, style_id, applied_to_item_id}
  6. Backend → PostgreSQL: Check if ANY MaterialInstances for item have style_id != 'normal'
  7. Backend → PostgreSQL: UPDATE Items.is_styled = (ANY applied material is styled)
  8. Image generation → Include all style_ids in combo_hash for visual consistency
  9. Generated item displays combined visual effects from all applied styled materials

tech_stack:
  frontend: "SwiftUI (native iOS/macOS), SwiftData (local persistence), CoreLocation (GPS), Google Maps SDK (map rendering)"
  backend: "Express.js 4.16.x (Node.js), Supabase SDK (auth + database), OpenAI/Anthropic SDK (AI generation)"
  database: "Supabase PostgreSQL with PostGIS (geospatial queries, combat session storage with TTL cleanup)"
  infrastructure: "Railway (backend hosting with auto-deploy), Supabase Cloud (database + auth), Google Cloud (Maps API), OpenAI/Anthropic (AI API)"

scalability_reliability:
  load_expectations: |
    - Light MVP (3 days): 10 concurrent users, local testing only
    - Full MVP (2 weeks): 100 concurrent users, beta testers
    - Finished Product (2 months): 1,000+ concurrent users, public launch
    - API response time target: <500ms for location/inventory queries, <200ms for combat actions
    - Database: ~10k locations globally, ~100k items/pets, ~1k active combat sessions at peak

  redundancy: |
    - Database: Supabase provides automated backups (daily snapshots, point-in-time recovery)
    - Backend: Railway auto-restarts on failure (max 10 retries per policy)
    - Redis: Ephemeral data (combat sessions) can be reconstructed, acceptable to lose on crash
    - Client: SwiftData caches critical data (inventory, equipped items) for offline resilience

  observability: |
    - Logging: Express.js Morgan middleware for request logging, sent to Railway logs
    - Monitoring: Railway dashboard for uptime, response time, error rate
    - Alerts: Configure Railway alerts for 5xx errors, response time > 2s, crash events
    - Analytics: Track key metrics (combat win rate, crafting frequency, location visits) via custom events to backend
    - Error Tracking: Sentry integration for client and backend error reporting (post-MVP)

security:
  authentication: "Supabase Auth with JWT tokens (1hr expiry), refresh tokens (30 days), secure Keychain storage on client"
  authorization: "Row-level security (RLS) in Supabase ensures players can only access their own items/inventory"
  api_security: "HTTPS only (enforced by Railway), CORS restricted to mobile app origins, rate limiting (100 req/min per IP)"
  data_privacy: "Email/password hashed by Supabase (bcrypt), no PII stored beyond email, GDPR-compliant account deletion endpoint"

performance_optimizations:
  client: |
    - SwiftData caches inventory, equipment locally (reduces API calls)
    - Map markers clustered when zoomed out (reduces rendering load)
    - Lazy loading for inventory lists (paginate 50 items at a time)
    - Combat animations at 60fps (hardware-accelerated SwiftUI)

  backend: |
    - Combat sessions stored in PostgreSQL with indexed lookups (CombatSessions.id primary key)
    - Location queries use PostGIS spatial index (O(log n) lookups)
    - AI-generated items cached in item_templates (avoid redundant API calls)
    - Database connection pooling (max 20 connections via Supabase)
    - Scheduled cleanup job removes expired combat sessions (created_at < NOW() - INTERVAL '15 minutes')

  database: |
    - Indexes on: owner_id, location_id, is_equipped, session_id, created_at (for TTL cleanup)
    - Geospatial index on locations (lat, lng) via PostGIS
    - CombatSessions.created_at indexed for efficient expired session cleanup

future_considerations:
  - Real-time multiplayer: WebSocket server for live co-op battles (Phase 2)
  - Trading system: Item marketplace with escrow transactions (Phase 2)
  - Leaderboards: Global/regional rankings by total stats or rare items collected
  - Push notifications: Daily quests, event notifications, crafting completion
  - Offline mode: Allow combat with cached enemies, sync on reconnect
  - Analytics dashboard: Admin panel to monitor game balance, player retention, economy health
