# Data Plan
# Defines data sources, tracking, storage, and metrics alignment.

status: draft
last_updated: 2025-10-20

data_sources:
  - source: "Supabase PostgreSQL"
    description: "Primary database for all persistent game data: users, items, pets, locations, enemies, combat sessions, material inventory, image cache"
    owner: "Backend Team"

  - source: "CoreLocation (iOS)"
    description: "Real-time GPS coordinates from player device for location tracking and proximity detection"
    owner: "Mobile Team"

  - source: "Google Maps API"
    description: "Map tiles, geocoding, and location data for map rendering"
    owner: "External (Google)"

  - source: "Materials Seed Data"
    description: "Pre-defined material library (~20 materials) with stat modifiers and metadata"
    owner: "Game Design Team"

  - source: "Supabase Auth"
    description: "User authentication, session tokens, and account management"
    owner: "External (Supabase)"

event_tracking:
  - event_name: "user_registered"
    trigger: "When player completes registration"
    properties:
      - "user_id: UUID"
      - "email: string (hashed)"
      - "registration_source: string (organic, referral, etc.)"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB", "Future: Mixpanel/Amplitude"]

  - event_name: "location_visited"
    trigger: "When player arrives within 50m of location marker"
    properties:
      - "user_id: UUID"
      - "location_id: UUID"
      - "distance_meters: int"
      - "enemy_type: string"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "combat_started"
    trigger: "When player initiates combat encounter"
    properties:
      - "user_id: UUID"
      - "location_id: UUID"
      - "enemy_id: UUID"
      - "enemy_type: string"
      - "enemy_is_shiny: boolean"
      - "player_total_stats: {atk, def, hp}"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "combat_completed"
    trigger: "When combat ends (victory or defeat)"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "result: string (victory, defeat)"
      - "turns_taken: int"
      - "damage_dealt: int"
      - "damage_received: int"
      - "reward_item_id: UUID (null if defeat)"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "item_equipped"
    trigger: "When player equips item to slot"
    properties:
      - "user_id: UUID"
      - "item_id: UUID"
      - "item_type: string"
      - "item_level: int"
      - "slot: string"
      - "new_total_stats: {atk, def, hp}"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "material_applied"
    trigger: "When player applies material to item"
    properties:
      - "user_id: UUID"
      - "item_id: UUID"
      - "material_id: string"
      - "is_shiny: boolean"
      - "material_index: int (0-2)"
      - "new_item_stats: object"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "material_replaced"
    trigger: "When player replaces material on item"
    properties:
      - "user_id: UUID"
      - "item_id: UUID"
      - "old_material_id: string"
      - "new_material_id: string"
      - "new_is_shiny: boolean"
      - "gold_spent: int"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "item_upgraded"
    trigger: "When player spends gold to level up item"
    properties:
      - "user_id: UUID"
      - "item_id: UUID"
      - "old_level: int"
      - "new_level: int"
      - "gold_spent: int"
      - "new_vanity_level: int"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "shiny_material_collected"
    trigger: "When player receives shiny material from combat"
    properties:
      - "user_id: UUID"
      - "material_id: string"
      - "location_id: UUID"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB", "Future: Push notification trigger"]

  - event_name: "session_started"
    trigger: "When player opens app and authenticates"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "device_type: string (iOS, macOS)"
      - "app_version: string"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "session_ended"
    trigger: "When player closes app or session expires"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "duration_seconds: int"
      - "locations_visited: int"
      - "combats_won: int"
      - "items_collected: int"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "pet_personality_assigned"
    trigger: "When player assigns or changes pet personality (F-11)"
    properties:
      - "user_id: UUID"
      - "pet_item_id: UUID"
      - "personality_type: string (sassy, encouraging, analytical, etc.)"
      - "custom_name: string (nullable)"
      - "previous_personality: string (nullable, if changing)"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "pet_chatter_generated"
    trigger: "When pet generates dialogue during combat (F-11)"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "pet_item_id: UUID"
      - "personality_type: string"
      - "event_type: string (player_attack, enemy_attack, victory, etc.)"
      - "dialogue_text: string (generated dialogue)"
      - "generation_time_ms: int (AI latency)"
      - "was_ai_generated: boolean (true if AI, false if fallback phrase)"
      - "turn_number: int"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "pet_chatter_displayed"
    trigger: "When pet dialogue is shown to player in UI (F-11)"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "dialogue_id: UUID (reference to combat_chatter_log)"
      - "display_duration_ms: int (how long shown on screen)"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "enemy_chatter_generated"
    trigger: "When enemy generates trash-talk during combat (F-12)"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "enemy_type: string (spray_paint_goblin, goopy_floating_eye, etc.)"
      - "dialogue_tone: string (aggressive, sarcastic, condescending, etc.)"
      - "event_type: string (combat_start, player_hit, player_miss, etc.)"
      - "dialogue_text: string (generated trash-talk)"
      - "generation_time_ms: int (AI latency)"
      - "was_ai_generated: boolean (true if AI, false if fallback taunt)"
      - "turn_number: int"
      - "player_context: object {attempts, victories, defeats, current_streak}"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "enemy_chatter_displayed"
    trigger: "When enemy dialogue is shown to player in UI (F-12)"
    properties:
      - "user_id: UUID"
      - "session_id: UUID"
      - "dialogue_id: UUID (reference to enemy_chatter_log)"
      - "display_duration_ms: int (how long shown on screen)"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

  - event_name: "combat_history_updated"
    trigger: "When player combat history is updated after combat (F-12)"
    properties:
      - "user_id: UUID"
      - "location_id: UUID"
      - "combat_result: string (victory, defeat)"
      - "new_attempts: int"
      - "new_victories: int"
      - "new_defeats: int"
      - "new_current_streak: int"
      - "previous_streak: int"
      - "timestamp: datetime"
    destinations: ["Backend Analytics DB"]

database_schema:
  core_entities: |
    **Users** (F-07 Authentication)
    - id: UUID (PK, Supabase Auth UUID)
    - email: VARCHAR (unique, from Supabase Auth)
    - created_at: TIMESTAMP
    - last_login: TIMESTAMP
    - vanity_level: INT (cached sum of all equipped item levels, maintained by trigger)
    - gold_balance: INT (currency, default 500)
    - avg_item_level: DECIMAL (cached average of equipped items for enemy scaling, maintained by trigger)
    - INDEX on (id, last_login)

    **EquipmentSlots** (seed data, 8 slots, source of truth for F-03)
    - slot_name: VARCHAR (PK: weapon, shield, head, armor, feet, accessory_1, accessory_2, pet)
    - display_name: VARCHAR (Weapon, Shield, Head, Armor, Feet, Accessory 1, Accessory 2, Pet)
    - sort_order: INT (UI display order)
    - description: TEXT

    **ItemTypes** (seed data, ~26 items across 8 slots, F-03 Base Items & Equipment)
    - id: UUID (PK)
    - name: VARCHAR (Enormous Key, Umbrella, Halo, Cowboy Hat, Leather Jacket, Fuzzy Slippers, A Rose, Candle, Dog, Dragon, Robot, etc.)
    - category: VARCHAR (weapon, shield, head, armor, feet, accessory, pet - maps to EquipmentSlots.slot_name)
    - base_stats_normalized: JSON {atkPower: 0.4, atkAccuracy: 0.2, defPower: 0.3, defAccuracy: 0.1} (sum = 1.0)
    - rarity: VARCHAR (common, uncommon, rare, epic, legendary)
    - description: TEXT (whimsical descriptions)
    - appearance_data: JSON (sprite info, colors, animations)
    - created_at: TIMESTAMP
    - INDEX on (category, rarity)
    - CHECK CONSTRAINT: (base_stats_normalized->>'atkPower')::numeric + (base_stats_normalized->>'atkAccuracy')::numeric + (base_stats_normalized->>'defPower')::numeric + (base_stats_normalized->>'defAccuracy')::numeric = 1.0

    **Items** (player-owned instances, F-03/F-06)
    - id: UUID (PK)
    - user_id: UUID (FK to Users)
    - item_type_id: UUID (FK to ItemTypes)
    - level: INT (default 1, upgraded via F-06 gold-based system)
    - current_stats: JSON (optional cache: base_stats * level + material modifiers, maintained by trigger OR computed on-read)
    - material_combo_hash: TEXT (nullable, deterministic hash of sorted material_ids + shiny flags for image lookup)
    - generated_image_url: TEXT (nullable, R2 URL to composite image for this item+materials combo)
    - image_generation_status: TEXT (nullable, CHECK IN ('pending','generating','complete','failed'))
    - created_at: TIMESTAMP
    - INDEX on (user_id, item_type_id)
    - INDEX on (user_id, level DESC)
    - INDEX on (material_combo_hash) WHERE material_combo_hash IS NOT NULL

    **UserUnlockedItemTypes** (F-03, tracking what players can craft/receive)
    - user_id: UUID (PK, FK to Users)
    - item_type_id: UUID (PK, FK to ItemTypes)
    - unlocked_at: TIMESTAMP
    - unlock_source: VARCHAR (combat_drop, starter_item, special_event)
    - UNIQUE (user_id, item_type_id)

    **UserEquipment** (F-03, normalized equipment state - SINGLE SOURCE OF TRUTH)
    - user_id: UUID (FK to Users, part of composite PK)
    - slot_name: VARCHAR (FK to EquipmentSlots.slot_name, part of composite PK)
    - item_id: UUID (nullable, FK to Items)
    - equipped_at: TIMESTAMP (when item was equipped to this slot)
    - PRIMARY KEY (user_id, slot_name)
    - INDEX on (user_id, slot_name)
    - INDEX on (item_id) WHERE item_id IS NOT NULL
    - CHECK CONSTRAINT: item_id IS NULL OR item_id IN (SELECT id FROM Items WHERE user_id = UserEquipment.user_id)
    - FK item_id → Items.id ON DELETE SET NULL
    - FK user_id → Users.id ON DELETE CASCADE
    - FK slot_name → EquipmentSlots.slot_name ON DELETE RESTRICT

    **Loadouts** (F-09, saved equipment configurations)
    - id: UUID (PK)
    - user_id: UUID (FK to Users)
    - name: VARCHAR (max 50 chars, player-defined name like "Boss Build", "Farming Build")
    - is_active: BOOLEAN (default false, only ONE loadout can be active per user)
    - created_at: TIMESTAMP
    - updated_at: TIMESTAMP
    - UNIQUE (user_id, name)
    - UNIQUE (user_id, is_active) WHERE is_active = true (partial unique index)
    - INDEX on (user_id, is_active)
    - FK user_id → Users.id ON DELETE CASCADE

    **LoadoutSlots** (F-09, items assigned to loadout slots)
    - loadout_id: UUID (FK to Loadouts, part of composite PK)
    - slot_name: VARCHAR (FK to EquipmentSlots.slot_name, part of composite PK)
    - item_id: UUID (nullable, FK to Items)
    - PRIMARY KEY (loadout_id, slot_name)
    - INDEX on (loadout_id, slot_name)
    - FK loadout_id → Loadouts.id ON DELETE CASCADE
    - FK slot_name → EquipmentSlots.slot_name ON DELETE RESTRICT
    - FK item_id → Items.id ON DELETE SET NULL

    **Materials** (seed data, ~20 materials, F-04 Materials System)
    - id: UUID (PK)
    - name: VARCHAR (Coffee, Gum, Feather, Propeller, Rainbow, Bubble, Slime, Diamond, Sparkles, A Cloud, Lava, Colorful Ribbon, Button, Candle, Pizza)
    - stat_modifiers: JSON {atkPower: -0.1, atkAccuracy: 0, defPower: +0.1, defAccuracy: 0} (sum = 0, zero-sum modifications)
    - rarity: VARCHAR (common, uncommon, rare, epic, legendary)
    - description: TEXT
    - created_at: TIMESTAMP
    - INDEX on (rarity)
    - CHECK CONSTRAINT: (stat_modifiers->>'atkPower')::numeric + (stat_modifiers->>'atkAccuracy')::numeric + (stat_modifiers->>'defPower')::numeric + (stat_modifiers->>'defAccuracy')::numeric = 0

    **MaterialInstances** (individual material instances when applied to items, F-04/F-05)
    - id: UUID (PK)
    - user_id: UUID (FK to Users)
    - material_id: UUID (FK to Materials)
    - is_shiny: BOOLEAN (5% drop rate, 1.2x stat effectiveness)
    - created_at: TIMESTAMP
    - INDEX on (user_id, material_id)
    - INDEX on (user_id, is_shiny) for inventory queries
    - FK user_id → Users.id ON DELETE CASCADE
    - FK material_id → Materials.id ON DELETE RESTRICT
    - NOTE: This table tracks individual material instances that are applied to items via ItemMaterials. For inventory stacking, see MaterialStacks.

    **MaterialStacks** (stackable material inventory, F-04/F-05)
    - user_id: UUID (part of composite PK, FK to Users)
    - material_id: UUID (part of composite PK, FK to Materials)
    - is_shiny: BOOLEAN (part of composite PK - shiny/normal stack separately)
    - quantity: INT NOT NULL CHECK (quantity >= 0) (how many of this material+shiny combo player owns)
    - updated_at: TIMESTAMP (when stack was last modified)
    - PRIMARY KEY (user_id, material_id, is_shiny)
    - INDEX on (user_id, is_shiny) for shiny material queries
    - FK user_id → Users.id ON DELETE CASCADE
    - FK material_id → Materials.id ON DELETE RESTRICT
    - NOTE: When materials are looted, increment quantity. When applied to items, decrement stack and create MaterialInstance row.

    **ItemMaterials** (F-04, junction table for materials applied to items - SINGLE SOURCE OF TRUTH)
    - id: UUID (PK)
    - item_id: UUID (FK to Items)
    - material_instance_id: UUID (FK to MaterialInstances, UNIQUE - prevents using same material twice)
    - slot_index: SMALLINT (0-2, which of the 3 material slots this occupies)
    - applied_at: TIMESTAMP
    - UNIQUE (item_id, slot_index) - prevents duplicate slot usage on same item
    - UNIQUE (material_instance_id) - prevents using same material instance on multiple items
    - INDEX on (item_id)
    - INDEX on (material_instance_id)
    - CHECK CONSTRAINT: slot_index BETWEEN 0 AND 2
    - FK item_id → Items.id ON DELETE CASCADE
    - FK material_instance_id → MaterialInstances.id ON DELETE CASCADE

    **Pets** (extends Items where category=pet, F-11 Pet Personality System)
    - item_id: UUID (PK, FK to Items where ItemTypes.category='pet')
    - personality_id: UUID (nullable, FK to PetPersonalities)
    - custom_name: VARCHAR (nullable, player-given name)
    - chatter_history: JSONB (recent dialogue for context)
    - INDEX on (item_id, personality_id)
    - CHECK CONSTRAINT: item_id IN (SELECT id FROM Items WHERE item_type_id IN (SELECT id FROM ItemTypes WHERE category='pet'))
    - FK item_id → Items.id ON DELETE CASCADE
    - FK personality_id → PetPersonalities.id ON DELETE SET NULL

    **ItemHistory** (audit trail for item lifecycle events)
    - id: UUID (PK)
    - item_id: UUID (FK to Items)
    - user_id: UUID (FK to Users)
    - event_type: VARCHAR (created, upgraded, material_applied, material_removed, equipped, unequipped, deleted)
    - event_data: JSONB (flexible payload: {old_level, new_level, gold_spent, material_id, slot_name, etc.})
    - created_at: TIMESTAMP
    - INDEX on (item_id, created_at DESC)
    - INDEX on (user_id, event_type, created_at DESC)
    - FK item_id → Items.id ON DELETE CASCADE
    - FK user_id → Users.id ON DELETE CASCADE

    **ItemImageCache** (global cache for item+material combo images)
    - id: UUID (PK)
    - item_type_id: UUID (FK to ItemTypes)
    - combo_hash: TEXT NOT NULL (deterministic hash: sorted material_ids + shiny flags, order-insensitive)
    - image_url: TEXT NOT NULL (R2 URL to generated composite image)
    - craft_count: INT NOT NULL DEFAULT 1 (how many times this combo has been crafted across all users)
    - provider: VARCHAR (nullable, AI provider used: gemini, seedream, etc.)
    - created_at: TIMESTAMP (when first generated)
    - UNIQUE (item_type_id, combo_hash)
    - INDEX on (combo_hash)
    - INDEX on (item_type_id, craft_count DESC) for "most popular combos" queries
    - FK item_type_id → ItemTypes.id ON DELETE CASCADE
    - NOTE: Global cache reused across all users. When materials applied, compute combo_hash and lookup here. If exists, reuse image_url and increment craft_count. If not, generate image (20s sync), upload to R2, create row.

    **PetPersonalities** (seed data, F-11)
    - id: UUID (PK)
    - personality_type: VARCHAR (UNIQUE: sassy, encouraging, analytical, chaotic, stoic, trash_talker)
    - display_name: VARCHAR (Sassy, Encouraging, Analytical, Chaotic, Stoic, Trash Talker)
    - description: TEXT
    - traits: JSON ARRAY (e.g., ['witty', 'sarcastic', 'confident'])
    - base_dialogue_style: TEXT (AI prompt template)
    - example_phrases: JSON ARRAY (fallback dialogue samples)
    - verbosity: VARCHAR (terse, moderate, verbose)

    **EnemyTypes** (seed data, F-12 Enemy AI Personality System)
    - id: UUID (PK)
    - name: VARCHAR (Spray Paint Goblin, Goopy Floating Eye, Ferral Unicorn, Bipedal Deer, Politician)
    - base_stats: JSON {attack: 100, defense: 80, accuracy: 0.7, health: 200} (scaled per combat)
    - ai_personality_traits: JSON ARRAY (['arrogant', 'street-smart', 'artistic'])
    - dialogue_tone: VARCHAR (aggressive, sarcastic, condescending, chaotic, political)
    - base_dialogue_prompt: TEXT (AI system prompt template)
    - example_taunts: JSON ARRAY (fallback phrases)
    - verbosity: VARCHAR (terse, moderate, verbose)
    - appearance_data: JSON (sprite info, animations)
    - INDEX on (name)

    **PlayerCombatHistory** (F-12, tracks performance per location)
    - user_id: UUID (PK, FK to Users)
    - location_id: UUID (PK, FK to Locations)
    - total_attempts: INT (total combat attempts at this location)
    - victories: INT (total wins)
    - defeats: INT (total losses)
    - current_streak: INT (consecutive wins, reset on loss)
    - longest_streak: INT (best streak ever at this location)
    - last_attempt: TIMESTAMP
    - UNIQUE (user_id, location_id)

    **Locations** (spawn points for combat encounters)
    - id: UUID (PK)
    - name: VARCHAR (generated descriptive names for markers)
    - lat: DECIMAL (latitude, 6 decimal places)
    - lng: DECIMAL (longitude, 6 decimal places)
    - location_type: VARCHAR (library, gym, park, coffee_shop, restaurant, school, etc.)
    - state_code: VARCHAR (US state code: CA, NY, TX, etc.)
    - country_code: VARCHAR (ISO country code: USA, CAN, etc.)
    - created_at: TIMESTAMP
    - INDEX on (lat, lng) via PostGIS for geospatial queries
    - INDEX on (location_type)

    **EnemyPools** (level-aware pool system for enemy spawn assignment)
    - id: UUID (PK)
    - name: VARCHAR (descriptive pool name: "Level 10 Library Enemies")
    - combat_level: INT (required - pools are level-specific)
    - filter_type: VARCHAR (universal | location_type | state | country | lat_range | lng_range)
    - filter_value: VARCHAR (nullable - specific filter criteria)
      Examples:
      * universal: filter_value = null (applies everywhere)
      * location_type: filter_value = "library" (matches locations.location_type)
      * state: filter_value = "CA" (matches locations.state_code)
      * country: filter_value = "USA" (matches locations.country_code)
      * lat_range: filter_value = "30-40N" (latitude range matching)
      * lng_range: filter_value = "120-130W" (longitude range matching)
    - created_at: TIMESTAMP
    - INDEX on (combat_level, filter_type)
    - UNIQUE (name) to prevent duplicate pool definitions

    **EnemyPoolMembers** (what enemies belong to each pool)
    - id: UUID (PK)
    - enemy_pool_id: UUID (FK to EnemyPools)
    - enemy_type_id: UUID (FK to EnemyTypes)
    - spawn_weight: INT (relative weight for random selection, default 100)
    - created_at: TIMESTAMP
    - INDEX on (enemy_pool_id)
    - UNIQUE (enemy_pool_id, enemy_type_id) to prevent duplicates

    **LootPools** (level-aware pool system for material/item drops)
    - id: UUID (PK)
    - name: VARCHAR (descriptive pool name: "Level 10 Library Loot")
    - combat_level: INT (required - pools are level-specific)
    - filter_type: VARCHAR (universal | location_type | state | country | lat_range | lng_range)
    - filter_value: VARCHAR (nullable - specific filter criteria, same format as EnemyPools)
    - created_at: TIMESTAMP
    - INDEX on (combat_level, filter_type)
    - UNIQUE (name) to prevent duplicate pool definitions

    **LootPoolEntries** (what loot belongs to each pool)
    - id: UUID (PK)
    - loot_pool_id: UUID (FK to LootPools)
    - lootable_type: VARCHAR (material | item_type)
    - lootable_id: UUID (FK to Materials.id or ItemTypes.id based on lootable_type)
    - drop_weight: INT (relative weight for random selection, default 100)
    - shiny_rate_override: DECIMAL (nullable, overrides default 5% for materials)
    - created_at: TIMESTAMP
    - INDEX on (loot_pool_id)
    - INDEX on (lootable_type, lootable_id)

    **CombatSessions** (F-02, stored in Redis with 15min TTL for active sessions)
    - id: UUID (PK)
    - user_id: UUID (FK to Users)
    - location_id: UUID (FK to Locations)
    - combat_level: INT (determined by player's avg_item_level)
    - enemy_type_id: UUID (FK to EnemyTypes, selected from matching EnemyPools)
    - applied_enemy_pools: JSON ARRAY (pool IDs that matched for enemy selection)
    - applied_loot_pools: JSON ARRAY (pool IDs that will be used for loot drops)
    - player_equipped_items_snapshot: JSON (stats at combat start)
    - combat_log: JSON ARRAY (turn-by-turn actions and damage)
    - outcome: VARCHAR (nullable: victory, defeat, abandoned)
    - rewards: JSON ARRAY (items/materials awarded on victory)
    - created_at: TIMESTAMP
    - updated_at: TIMESTAMP

  analytics_tables: |
    **CombatChatterLog** (F-11 Pet Personality analytics)
    - id: UUID (PK)
    - session_id: UUID (FK to CombatSessions)
    - pet_item_id: UUID (FK to Items)
    - event_type: VARCHAR (player_attack, enemy_attack, critical_hit, victory, defeat)
    - combat_context: JSON {turn_number, player_hp_pct, enemy_hp_pct, last_damage}
    - generated_dialogue: TEXT
    - personality_type: VARCHAR
    - generation_time_ms: INT
    - was_ai_generated: BOOLEAN
    - timestamp: TIMESTAMP
    - INDEX on (session_id, timestamp)
    - INDEX on (personality_type, event_type)

    **EnemyChatterLog** (F-12 Enemy AI analytics)
    - id: UUID (PK)
    - session_id: UUID (FK to CombatSessions)
    - enemy_type_id: UUID (FK to EnemyTypes)
    - event_type: VARCHAR (combat_start, player_hit, player_miss, enemy_hit, low_player_hp, near_victory, defeat, victory)
    - combat_context: JSON {turn_number, player_hp_pct, enemy_hp_pct, last_action, damage}
    - player_metadata: JSON {attempts, victories, defeats, current_streak}
    - generated_dialogue: TEXT
    - dialogue_tone: VARCHAR
    - generation_time_ms: INT
    - was_ai_generated: BOOLEAN
    - timestamp: TIMESTAMP
    - INDEX on (session_id, timestamp)
    - INDEX on (enemy_type_id, event_type)

    **AnalyticsEvents** (general event tracking)
    - id: UUID (PK)
    - user_id: UUID (FK to Users, nullable)
    - event_name: VARCHAR
    - properties: JSONB
    - timestamp: TIMESTAMP
    - INDEX on (event_name, timestamp)

  seed_data_notes: |
    **ItemTypes Examples:**
    - Weapons: Enormous Key, Gatling Gun, Sword, Umbrella (whimsical but recognizable)
    - Armor: Halo (helmet), protective items with magical/mundane themes
    - Accessories: Shiny Coin (amulet), A Rose (ring), Cupcake, Jar of Jelly
    - Pets: Dog, Dragon, Unicorn, Lil Buddy, Robot (each with distinct personalities)

    **Materials Examples:**
    - Common: Coffee (+energy/-defense), Gum (sticky effects), Button (small modifier)
    - Rare: Rainbow (balanced stats), Diamond (+defense/-speed), Lava (+attack/-accuracy)
    - Legendary: A Cloud (ethereal effects), Colorful Ribbon (aesthetic + stats)

    **Enemy Types Examples:**
    - Spray Paint Goblin: Street-smart, artistic, sarcastic dialogue
    - Goopy Floating Eye: All-seeing, ominous, condescending tone
    - Ferral Unicorn: Wild, unpredictable, chaotic personality
    - Bipedal Deer: Forest-wise, territorial, moderate aggression
    - Politician: Manipulative, eloquent, verbose political speak

    **Pool System Examples:**

    **EnemyPools:**
    - {id: uuid-1, name: "Level 10 Universal Enemies", combat_level: 10, filter_type: "universal", filter_value: null}
    - {id: uuid-2, name: "Level 10 Library Enemies", combat_level: 10, filter_type: "location_type", filter_value: "library"}
    - {id: uuid-3, name: "Level 10 California Enemies", combat_level: 10, filter_type: "state", filter_value: "CA"}
    - {id: uuid-4, name: "Level 10 USA Enemies", combat_level: 10, filter_type: "country", filter_value: "USA"}
    - {id: uuid-5, name: "Level 15 Library Enemies", combat_level: 15, filter_type: "location_type", filter_value: "library"}
    - {id: uuid-6, name: "Level 10 North America Lat", combat_level: 10, filter_type: "lat_range", filter_value: "30-50N"}

    **EnemyPoolMembers:**
    - {enemy_pool_id: uuid-1, enemy_type_id: spray_paint_goblin_id, spawn_weight: 100}
    - {enemy_pool_id: uuid-1, enemy_type_id: goopy_floating_eye_id, spawn_weight: 80}
    - {enemy_pool_id: uuid-2, enemy_type_id: politician_id, spawn_weight: 150} // Higher weight in libraries
    - {enemy_pool_id: uuid-3, enemy_type_id: ferral_unicorn_id, spawn_weight: 120} // California-specific

    **LootPools:**
    - {id: uuid-10, name: "Level 10 Universal Loot", combat_level: 10, filter_type: "universal", filter_value: null}
    - {id: uuid-11, name: "Level 10 Library Loot", combat_level: 10, filter_type: "location_type", filter_value: "library"}
    - {id: uuid-12, name: "Level 10 California Loot", combat_level: 10, filter_type: "state", filter_value: "CA"}
    - {id: uuid-13, name: "Level 10 Coffee Shop Loot", combat_level: 10, filter_type: "location_type", filter_value: "coffee_shop"}

    **LootPoolEntries:**
    - {loot_pool_id: uuid-10, lootable_type: "material", lootable_id: iron_material_id, drop_weight: 100, shiny_rate_override: null}
    - {loot_pool_id: uuid-11, lootable_type: "material", lootable_id: paper_material_id, drop_weight: 200, shiny_rate_override: null} // Books/paper in libraries
    - {loot_pool_id: uuid-11, lootable_type: "item_type", lootable_id: enormous_key_id, drop_weight: 50, shiny_rate_override: null} // Rare book-themed items
    - {loot_pool_id: uuid-13, lootable_type: "material", lootable_id: coffee_material_id, drop_weight: 300, shiny_rate_override: 0.15} // 15% shiny rate for coffee

    **Example Combat Query (Level 10 library in California):**
    Location: {location_type: "library", state_code: "CA", country_code: "USA", lat: 37.7, lng: -122.4}
    Combat Level: 10

    Matching EnemyPools:
    - uuid-1 (Universal Level 10)
    - uuid-2 (Library Level 10)
    - uuid-3 (California Level 10)
    - uuid-4 (USA Level 10)
    - uuid-6 (North America Lat Level 10, if 37.7 is in 30-50N range)

    Combined Enemy Selection:
    - spray_paint_goblin: weight 100 (from universal)
    - goopy_floating_eye: weight 80 (from universal)
    - politician: weight 150 (from library)
    - ferral_unicorn: weight 120 (from California)
    // Weighted random selection from this combined pool

    Matching LootPools:
    - uuid-10 (Universal Level 10)
    - uuid-11 (Library Level 10)
    - uuid-12 (California Level 10)
    // Combined loot table for drops

  data_relationships: |
    **Core Ownership Chain:**
    Users → Items (via user_id) → ItemTypes (via item_type_id)
    Users → MaterialStacks (stackable material inventory)
    Users → MaterialInstances (individual material instances for application)
    MaterialStacks → Materials (via material_id)
    MaterialInstances → Materials (via material_id)
    Items ← ItemMaterials → MaterialInstances (junction table for materials applied to items)

    **Equipment System (NEW - normalized):**
    Users → UserEquipment → Items (8 slots: weapon, shield, head, armor, feet, accessory_1, accessory_2, pet)
    Users → Loadouts (saved equipment configurations)
    Loadouts → LoadoutSlots → Items (per-loadout slot assignments)
    UserEquipment.slot_name → EquipmentSlots.slot_name (validates slot exists)
    LoadoutSlots.slot_name → EquipmentSlots.slot_name (validates slot exists)

    **Material Application (NEW - normalized):**
    Items → ItemMaterials → MaterialInstances (max 3 per item, slot_index 0-2)
    ItemMaterials enforces UNIQUE(material_instance_id) - prevents reusing same material
    ItemMaterials enforces UNIQUE(item_id, slot_index) - prevents duplicate slot usage
    MaterialStacks: When loot drops, increment quantity. When applying to item, decrement stack and create MaterialInstance.

    **Image Generation Workflow:**
    Items.material_combo_hash → ItemImageCache.combo_hash (lookup generated images)
    ItemImageCache: Global cache across all users, keyed by (item_type_id, combo_hash)
    On material application:
      1. Compute combo_hash from sorted material_ids + shiny flags (order-insensitive)
      2. Lookup ItemImageCache by (item_type_id, combo_hash)
      3. If exists: Reuse image_url, increment craft_count, update Items.generated_image_url
      4. If not exists: Generate image (20s sync via scripts/generate-image.ts), upload to R2, insert ItemImageCache row
      5. Update Items: material_combo_hash, generated_image_url, image_generation_status='complete'

    **Location & Pool System:**
    Locations → CombatSessions (spawn point selection)
    EnemyPools → EnemyPoolMembers → EnemyTypes (pool-based enemy assignment)
    LootPools → LootPoolEntries → Materials|ItemTypes (pool-based loot drops)
    Locations.{location_type, state_code, country_code, lat, lng} → EnemyPools.{filter_type, filter_value} (pool matching logic)

    **Combat Flow:**
    Users → CombatSessions → EnemyTypes (selected via EnemyPools)
    Users → PlayerCombatHistory (per location performance tracking)
    CombatSessions → CombatChatterLog (pet dialogue)
    CombatSessions → EnemyChatterLog (enemy trash-talk)
    CombatSessions.applied_enemy_pools → EnemyPools (which pools were used for enemy selection)
    CombatSessions.applied_loot_pools → LootPools (which pools will be used for loot drops)

    **Pet System:**
    Items (where ItemTypes.category='pet') → Pets → PetPersonalities
    Pets → CombatChatterLog (dialogue generation)
    Pets.item_id constrained to Items with category='pet' via CHECK constraint

    **Unlocks & Progression:**
    Users → UserUnlockedItemTypes → ItemTypes (what can be obtained)
    Items.level progression via F-06 Item Upgrade System
    MaterialInstances.is_shiny (5% drop rate, 1.2x effectiveness)

    **Audit Trail:**
    Items → ItemHistory (lifecycle events: created, upgraded, material_applied, equipped, etc.)

    **Pool Query Logic:**
    At combat initialization:
    1. Get Location.{location_type, state_code, country_code, lat, lng}
    2. Get player's combat_level from avg_item_level
    3. Query EnemyPools WHERE:
       - combat_level = player_combat_level AND
       - (filter_type = 'universal' AND filter_value IS NULL) OR
       - (filter_type = 'location_type' AND filter_value = Location.location_type) OR
       - (filter_type = 'state' AND filter_value = Location.state_code) OR
       - (filter_type = 'country' AND filter_value = Location.country_code) OR
       - (filter_type = 'lat_range' AND Location.lat BETWEEN parsed_range) OR
       - (filter_type = 'lng_range' AND Location.lng BETWEEN parsed_range)
    4. UNION all matching EnemyPoolMembers, aggregate by enemy_type_id with SUM(spawn_weight)
    5. Weighted random selection of enemy_type_id for combat
    6. Repeat same logic for LootPools → LootPoolEntries for loot drop determination

  constraints_and_indexes: |
    **Primary Constraints:**
    - Users.id matches Supabase Auth UUID (managed by Supabase)
    - Materials.stat_modifiers sum = 0 (enforced via CHECK constraint)
    - ItemTypes.base_stats_normalized sum = 1.0 (enforced via CHECK constraint)
    - ItemMaterials.slot_index BETWEEN 0 AND 2 (enforced via CHECK constraint)
    - Pets.item_id must reference Items with category='pet' (enforced via CHECK constraint)
    - CombatSessions Redis TTL = 15 minutes (ephemeral active combat)

    **Unique Constraints (prevent data inconsistencies):**
    - UserEquipment: UNIQUE(user_id, slot_name) - one item per slot
    - ItemMaterials: UNIQUE(item_id, slot_index) - no duplicate material slots
    - ItemMaterials: UNIQUE(material_instance_id) - material can only be applied to one item
    - Loadouts: UNIQUE(user_id, name) - unique loadout names per user
    - Loadouts: UNIQUE(user_id, is_active) WHERE is_active = true - only one active loadout per user
    - LoadoutSlots: UNIQUE(loadout_id, slot_name) - one item per slot per loadout
    - MaterialStacks: PRIMARY KEY (user_id, material_id, is_shiny) - one stack per material+shiny combo
    - ItemImageCache: UNIQUE(item_type_id, combo_hash) - one cached image per item+material combo

    **Performance Indexes:**
    - Items: (user_id, item_type_id) for duplicate detection
    - Items: (user_id, level DESC) for inventory sorting
    - Items: (material_combo_hash) WHERE material_combo_hash IS NOT NULL for image lookup
    - UserEquipment: (user_id, slot_name) unique index for equipment queries
    - UserEquipment: (item_id) WHERE item_id IS NOT NULL for reverse lookups
    - Loadouts: (user_id, is_active) for active loadout queries
    - LoadoutSlots: (loadout_id, slot_name) unique index
    - ItemMaterials: (item_id) for material lookup by item
    - ItemMaterials: (material_instance_id) for reverse material lookups
    - MaterialInstances: (user_id, material_id) for material inventory
    - MaterialInstances: (user_id, is_shiny) for shiny material queries
    - MaterialStacks: PRIMARY KEY (user_id, material_id, is_shiny) for inventory queries
    - MaterialStacks: (user_id, is_shiny) for shiny material inventory
    - ItemImageCache: (combo_hash) for fast image lookup
    - ItemImageCache: (item_type_id, combo_hash) UNIQUE for cache integrity
    - ItemImageCache: (item_type_id, craft_count DESC) for popular combo queries
    - ItemHistory: (item_id, created_at DESC) for audit trail
    - ItemHistory: (user_id, event_type, created_at DESC) for user event history
    - PlayerCombatHistory: (user_id, location_id) unique constraint
    - CombatChatterLog: (session_id, timestamp) for combat dialogue timeline
    - EnemyChatterLog: (session_id, timestamp) for enemy dialogue timeline
    - AnalyticsEvents: (event_name, timestamp) for metrics queries
    - Locations: (lat, lng) PostGIS spatial index for geospatial queries
    - Locations: (location_type) for pool filtering
    - EnemyPools: (combat_level, filter_type) for pool query optimization
    - EnemyPoolMembers: (enemy_pool_id) for pool member lookup
    - LootPools: (combat_level, filter_type) for pool query optimization
    - LootPoolEntries: (loot_pool_id) for pool entry lookup
    - LootPoolEntries: (lootable_type, lootable_id) for reverse lookups
    - Pets: (item_id, personality_id) for pet personality queries

    **Foreign Key Relationships:**
    - All user_id fields → Users.id (CASCADE DELETE for GDPR compliance)
    - Items.item_type_id → ItemTypes.id (RESTRICT, seed data)
    - UserEquipment.user_id → Users.id (CASCADE DELETE)
    - UserEquipment.slot_name → EquipmentSlots.slot_name (RESTRICT)
    - UserEquipment.item_id → Items.id (SET NULL on item deletion)
    - Loadouts.user_id → Users.id (CASCADE DELETE)
    - LoadoutSlots.loadout_id → Loadouts.id (CASCADE DELETE)
    - LoadoutSlots.slot_name → EquipmentSlots.slot_name (RESTRICT)
    - LoadoutSlots.item_id → Items.id (SET NULL on item deletion)
    - MaterialStacks.user_id → Users.id (CASCADE DELETE)
    - MaterialStacks.material_id → Materials.id (RESTRICT, seed data)
    - MaterialInstances.user_id → Users.id (CASCADE DELETE)
    - MaterialInstances.material_id → Materials.id (RESTRICT, seed data)
    - ItemMaterials.item_id → Items.id (CASCADE DELETE)
    - ItemMaterials.material_instance_id → MaterialInstances.id (CASCADE DELETE)
    - ItemImageCache.item_type_id → ItemTypes.id (CASCADE DELETE)
    - ItemHistory.item_id → Items.id (CASCADE DELETE)
    - ItemHistory.user_id → Users.id (CASCADE DELETE)
    - Pets.item_id → Items.id (CASCADE DELETE)
    - Pets.personality_id → PetPersonalities.id (SET NULL, personality can be unassigned)
    - CombatSessions.location_id → Locations.id (RESTRICT, locations are persistent)
    - CombatSessions.enemy_type_id → EnemyTypes.id (RESTRICT, seed data)
    - EnemyPoolMembers.enemy_pool_id → EnemyPools.id (CASCADE DELETE)
    - EnemyPoolMembers.enemy_type_id → EnemyTypes.id (RESTRICT, seed data)
    - LootPoolEntries.loot_pool_id → LootPools.id (CASCADE DELETE)
    - LootPoolEntries.lootable_id → Materials.id|ItemTypes.id (RESTRICT, depends on lootable_type)
    - PlayerCombatHistory.location_id → Locations.id (CASCADE DELETE if location removed)

    **Database Triggers (for cache maintenance):**
    - ON UserEquipment INSERT/UPDATE/DELETE → recalculate Users.vanity_level, Users.avg_item_level
    - ON Items.level UPDATE → recalculate Users.vanity_level, Users.avg_item_level (if equipped)
    - ON ItemMaterials INSERT/UPDATE/DELETE → recalculate Items.current_stats (if using cached stats)
    - ON Items.level UPDATE → recalculate Items.current_stats (if using cached stats)
    - ON ItemMaterials INSERT/UPDATE/DELETE → recompute Items.material_combo_hash (deterministic hash of sorted material_ids + shiny flags)
    - ON Items.material_combo_hash UPDATE (when changed) → set image_generation_status='pending', lookup ItemImageCache, queue image generation if not exists

  migration_considerations: |
    **5-Phase Migration Strategy:**

    **Phase 1 - Foundation (additive, non-breaking):**
    - Create EquipmentSlots seed table (8 slots: weapon, shield, head, armor, feet, accessory_1, accessory_2, pet)
    - Create UserEquipment, ItemMaterials, ItemHistory junction tables
    - Backfill UserEquipment from existing Items.equipped/equipped_slot if present
    - Backfill ItemMaterials from Items.applied_material_slots JSON if present
    - Add UNIQUE constraints on new tables
    - Keep old fields temporarily for backward compatibility

    **Phase 2 - Slot Model Alignment:**
    - Standardize to 8-slot model across all docs (data-plan, api-contracts, F-03)
    - Update ItemTypes.category to include: weapon, shield, head, armor, feet, accessory, pet
    - Update seed-data-items.json to use standardized slot names
    - Extend GET /equipment API response to return 8 slots
    - Update frontend UI to support 8 equipment slots

    **Phase 3 - Loadouts System:**
    - Create Loadouts and LoadoutSlots tables
    - Add Loadout API endpoints: GET/POST /loadouts, PUT /loadouts/{id}/activate
    - Implement loadout switching logic (copy LoadoutSlots → UserEquipment on activate)
    - Add loadout UI in frontend

    **Phase 4 - Deprecations (breaking changes):**
    - Deprecate Items.equipped and Items.equipped_slot columns
    - Deprecate Items.applied_material_slots JSON column
    - Migrate all client code to use UserEquipment and ItemMaterials
    - Drop deprecated columns after migration grace period

    **Phase 5 - Triggers and Optimization:**
    - Add database triggers for Users.vanity_level and Users.avg_item_level maintenance
    - Add trigger for Items.current_stats recalculation (if using cached stats)
    - Add CHECK constraints for stat sums (Materials, ItemTypes)
    - Add CHECK constraint for Pets.item_id category validation
    - Add analytics table partitioning by month for time-series data (CombatChatterLog, EnemyChatterLog)

    **Schema Evolution Roadmap:**
    - MVP Phase 1: Users, EquipmentSlots, ItemTypes, Items, UserEquipment, Materials, MaterialStacks, MaterialInstances, ItemMaterials, ItemImageCache
    - MVP Phase 2: Locations, EnemyTypes, LootPools, LootPoolEntries when geolocation (F-01) implemented
    - Post-MVP: Loadouts, LoadoutSlots, ItemHistory, PetPersonalities, Pets when F-11 implemented
    - Analytics: Add analytics tables incrementally as events are defined

    **Data Seeding Priority:**
    1. EquipmentSlots (8 slots - required first)
    2. ItemTypes (26 items across 8 slots)
    3. Materials (20 materials with stat modifiers)
    4. Locations (spawn points for combat)
    5. EnemyTypes (combat enemies with AI personalities)
    6. EnemyPools + EnemyPoolMembers (level-aware enemy spawning)
    7. LootPools + LootPoolEntries (location-specific loot drops)
    8. PetPersonalities (F-11 personality types)

    **Performance Considerations:**
    - Items table will be largest (thousands per user, 10K-100K rows)
    - MaterialStacks reduces rows compared to individual MaterialInstances (stackable inventory, ~20-100 rows per user)
    - MaterialInstances only created on material application (moderate insert frequency, 1K-10K rows)
    - UserEquipment normalized queries faster than JSON parsing (8 rows per user vs JSON field)
    - ItemMaterials normalized queries faster than JSON parsing (3 rows per item vs JSON field)
    - ItemImageCache global reuse reduces R2 API calls (one image per unique combo, ~5K-50K combos total)
    - Image generation is sync (20s) but cached globally, so most combos will be instant lookups
    - CombatSessions in Redis avoids PostgreSQL load during active combat (ephemeral)
    - Locations table optimized with PostGIS spatial indexes (sub-50ms geospatial queries)
    - Pool query logic optimized with composite indexes (combat_level, filter_type)
    - Analytics tables will need partitioning by month after 1M+ rows (time-series optimization)
    - Trigger overhead on UserEquipment changes: ~1-2ms for vanity_level recalculation (acceptable)
    - Trigger overhead on ItemMaterials changes: ~2-3ms for combo_hash recalculation + image lookup (acceptable)

    **Rollback Strategy:**
    - Phase 1-3 are additive: can roll back by ignoring new tables
    - Phase 4 requires migration rollback: restore Items.equipped/applied_material_slots from UserEquipment/ItemMaterials
    - Phase 5 triggers can be dropped without data loss (revert to on-read computation)

data_storage:

  retention_policy: |
    - User accounts: Retain indefinitely unless user requests deletion (GDPR)
    - Player items: Retain as long as user account exists
    - Player materials: Retain as long as user account exists
    - Combat sessions (Redis): Expire after 15 minutes (ephemeral)
    - Analytics events: Retain for 2 years, then archive or delete
    - Logs: Retain for 90 days (Railway default)